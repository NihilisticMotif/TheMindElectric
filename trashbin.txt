(e)=>
 
// <>
// <P00_Header/>
// <P01_LeftPanel/>
// </>
 
let_ThisPanel!.setAttribute("style","width:"+SS_Width.toString()+"px");
 
let let_ThisPanel=document.getElementById('P01id_Div')
 
setSS_Width()
 
        let let_NewWidth:number=0
 
        const setFromEvent = (e) => setSS_MouseX({ x: e.clientX, y: e.clientY });
        window.addEventListener("mousemove", setFromEvent);

        return () => {
          window.removeEventListener("mousemove", setFromEvent);
        };
 
            alert(let_ColorOfTheWind)
 
            alert(let_ColorOfTheWind)
 
    style={{backgroundColor: let_ColorOfTheWind}}
 
            setSS_IsMouseDown(true)
 
            setSS_IsMouseDown(false)
 
"white"
 
let let_ThisPanel=document.getElementById('P01id_Div')
        let_ThisPanel!.setAttribute("style","width:"+SS_Width.toString()+"px");
 
=false
 
        let let_WIDTH:number=SS_Width
 
        let let_width:number=let_WIDTH-5
 
        let_thisPanel!.setAttribute("style","width:"+let_width.toString()+"px");
 
        let let_thisPanel=document.getElementById('P01id_Div')
 

#P01id_div {
    background-color: rgb(102, 183, 36);
    /*
https://stackoverflow.com/questions/7357818/how-can-an-html-element-fill-out-100-of-the-remaining-screen-height-using-css
*/
    height: 100vh;
    width: 495px;
    margin: 0;
    padding: 0;
}
 
et let_OffSetWidth:number=SS_Width
        if(let_OffSetWidth-mouseX<5){
            alert('Line Zone')
        }
        //alert(let_ThisPanel!.offsetWidth)
 
    const [SS_Width,setSS_Width]=useState<number>(500)
    const Ref_Click = useRef<number>(0)

    useEffect(()=>{
        let let_WIDTH:number=SS_Width
        let let_width:number=let_WIDTH-5
        let let_THISPanel=document.getElementById('P01id_Div')
        let let_thisPanel=document.getElementById('P01id_Div')
        let_THISPanel!.setAttribute("style","width:"+let_WIDTH.toString()+"px");
        let_thisPanel!.setAttribute("style","width:"+let_width.toString()+"px");
    },[SS_Width]
    )
 
</div>
 
<div id='P01id_div' >
 
        let let_ThisPanel=document.getElementById('P01id_Div')
 
let let_OffSetWidth:number=let_ThisPanel!.offsetWidth
 
    draggable
 
    width: 495px;
 
    width: 500px;
 
        const mouseY:number = e.clientY;
        //alert('Mouse:'+mouseX.toString()+','+mouseY.toString());
 
</div>
 
e: React.MouseEvent<HTMLDivElement>
 
width()
 
.pageX
 
            <div>
                <div className="content">
                    <h3 className="h3">Chart </h3>
                    ASP.NET charts, a well-crafted easy-to-use charting package, is used to add beautiful charts in web and mobile applications
                </div>
            </div>
 
import SplitPane from "split-pane-react/esm/SplitPane";

// Initialize Splitter control
let splitObject: SplitPane = new Splitter({
    height: '250px',
    paneSettings: [
        { size: '200px' },
        { size: '200px' },
        { size: '200px' }
    ],
    width: '600px'
});

// Render initialized Splitter
splitObject.appendTo('#splitter');
 
 from '@syncfusion/ej2-layouts';
 
import { Splitter } from '@syncfusion/ej2-layouts';

// Initialize Splitter control
let splitObject: Splitter = new Splitter({
    height: '250px',
    paneSettings: [
        { size: '200px' },
        { size: '200px' },
        { size: '200px' }
    ],
    width: '600px'
});

// Render initialized Splitter
splitObject.appendTo('#splitter');
 
P02_Canvas
 
import React, { useState } from 'react';
import SplitPane, { Pane } from 'split-pane-react';
import 'split-pane-react/esm/themes/default.css';

const P02_Canvas=()=>{
  const [sizes, setSizes] = useState([100, '30%', 'auto']);

  const layoutCSS = {
    height: '100%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  };

  return (
    <div style={{ height: 500 }}>
      <SplitPane
        split='vertical'
        sizes={sizes}
        onChange={setSizes}
      >
        <Pane minSize={50} maxSize='50%'>
          <div style={{ ...layoutCSS, background: '#ddd' }}>
            pane1
          </div>
        </Pane>
        <div style={{ ...layoutCSS, background: '#d5d7d9' }}>
          pane2
        </div>
        <div style={{ ...layoutCSS, background: '#a1a5a9' }}>
          pane3
        </div>
      </SplitPane>
    </div>
  );
};

 
    main_text:80%
 
<P00_Header/>
 
</div>
 
<div className='Id_Space'>
 

.Id_Space{
    margin-bottom:0px
}
 
</div>
 

//****************************************************************************
// INPUT
//****************************************************************************
{
// PARAMETER
// PERPERTY
// HOOK
}:{
// TYPE
// PERPERTY
// HOOK
}

 
height: 50px;
 
    margin:0
 
<button>Open</button>
<button>Login</button>
<button>Help</button>
<button>Save</button>
<button>Import Data</button>
<button>Export Data</button>
<button>Export Image</button>
 
</div>
 
<div id='Body' >

</div>
 
<P00_Header/>
 
<P01_LeftPanel/>
 
</>
 
    width: 100%;
 
    display: flex;
 
<h2>The Mind Electric</h2>
 
<h2>The Mind Electric</h2>
 
<button>Import Data</button>
<button>Export Data</button>
<button>Export Image</button>
 
<button>Open</button>
 
<button>Export Image</button>
 
<h2>The Mind Electric</h2>
 
<h2>The Mind Electric</h2>
 
<h2>The Mind Electric</h2>
 
    */
 
    /*
 
135, 17, 17), 0, 0)
 
</div>
 
<div id='App'>
 
#App {
}
 
    width: 1000px;
    overflow-x: scroll;
    overflow-y: scroll;
 
    border: 3px solid rgb(255, 255, 255);
 

#AddInput {

}
 
    height: 40px;
    font-size: 25px;
 
    border: 3px solid rgb(255, 255, 255);
 
    border: 3px solid rgb(255, 255, 255);
 
<C00_Header/>
 
<>
<table id='C99id_Table'>
<tr>
    {JSX_TH_Column_S}
    <th>Edit</th>
</tr>
<tr>
    {JSX_BUTTON_Column_S}
    <td>-</td>
</tr>

</table>
</>
 
    const letPerson_S:TS_Person[]=[
        {Name:'Mumu'  , Gender:false, Age: 25},
        {Name:'CheChe', Gender: true, Age: 22},
        {Name:'Tata'  , Gender: true, Age: 19}
    ]

    const JSX_TH_Column_S:JSX.Element[] = letPerson_S.map(Column => <th>{Column.Name+','+Column.Gender.toString()+','+Column.Age.toString()}</th>);
    const JSX_BUTTON_Column_S:JSX.Element[] = letPerson_S.map(Column=>
        <td>
            <div id='C99id_Button'>
            <button>Edit</button>
            </div>
        </td>
        );
 
/*
 
<C02_ColumnName 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns02}
setSS_IndexColumns={setSS_IndexColumns02}
/>
<C01_Table 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns01}
setSS_IndexColumns={setSS_IndexColumns01}
/>
 
<div id='Body' >
<C02_ColumnName 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns02}
setSS_IndexColumns={setSS_IndexColumns02}
/>
<C01_Table 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns01}
setSS_IndexColumns={setSS_IndexColumns01}
/>
</div>
 
<div id='Body' >
<C02_ColumnName 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns02}
setSS_IndexColumns={setSS_IndexColumns02}
/>
<C01_Table 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns01}
setSS_IndexColumns={setSS_IndexColumns01}
/>
 

<C01_Table 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns01}
setSS_IndexColumns={setSS_IndexColumns01}
/>
 
<C01_Table 
SS_Columns={SS_Columns}
setSS_Columns={setSS_Columns}
SS_IndexColumns={SS_IndexColumns01}
setSS_IndexColumns={setSS_IndexColumns01}
/>
 

{JSX_DivTestColumn}
 
            // style={{ whiteSpace: 'nowrap' }}
 
 
 
                    </div>
 
                    <div className='C01id_P'>
 
                    </div>
 
                    <div>
 
 style={{ whiteSpace: 'nowrap' }}
 
</div>
 
</div>
 
Do you want to unselect 
 
 {Column.Name}
 
Do you want to delete 
 
 {Column.Name}
 

            //onDragEnter={(e) => {
            //    // Update the Ref_DragOverColumn.current only if the drag is happening horizontally
            //    if (e.clientX >= e.currentTarget.getBoundingClientRect().left && e.clientX <= e.currentTarget.getBoundingClientRect().right) {
            //      Ref_DragOverColumn.current = index;
            //    }
            //    }}
 
        const isDragged:boolean = index === Ref_DragColumn.current;
 
            style={{ backgroundColor: isDragged ? 'black':'', cursor: 'grab' }}
 
 : 'blue'
 
            style={{ backgroundColor: 'lightblue', cursor: 'grab' }}
 
 : 'white'
 
isDragged ? 
 
    // Fix this line
 
        alert(ss_IndexColumns)
 
        alert(ss_IndexColumns)
 
 key={SS_PrivateReset}
 
        setSS_PrivateReset(Math.random())
 
    // Only Reset after f_Drag
    const [SS_PrivateReset,setSS_PrivateReset]=useState<number>(0)
 
ss_Celumns:TS_ColumnName[]
 
SS_IndexColumns
 
[Ref_DragColumn.current]
 


 
// 
 
            //onDragStart={()=>alert(index)}
            //onDragEnter={()=>alert(index)}
            onDragEnter={()=>{alert(Ref_DragOverColumn.current)}}
 
=index
 
        //alert(JSON.stringify(SS_PrivateColumn))
 


  //  if(SS_IndexColumns01.length>SS_IndexColumns02.length && SS_IndexColumns01.length>SS_Columns.length){
  //      
  //  }
 


  // // Delete SS_IndexColumns01 non-exist key
  // for(let i:number=0;i<SS_IndexColumns01.length;i++){
  //     if(ss_IndexColumns.includes(SS_IndexColumns01[i])===false){
  //         let ss_IndexColumns01:number[]=SS_IndexColumns01
  //         setSS_IndexColumns01(ss_IndexColumns01.splice(i,1))
  //     }
  // }

  // // Delete SS_IndexColumns02 non-exist key
  // for(let i:number=0;i<SS_IndexColumns02.length;i++){
  //     if(ss_IndexColumns.includes(SS_IndexColumns02[i])===false){
  //         let ss_IndexColumns02:number[]=SS_IndexColumns02
  //         setSS_IndexColumns02(ss_IndexColumns02.splice(i,1))
  //     }
  // }

    /*
    // Update SS_IndexColumns01 everytime SS_IndexColumns02 is added
    for(let i:number=0;i<SS_IndexColumns02.length;i++){
        if(SS_IndexColumns01.includes(SS_IndexColumns02[i])===false){
            let ss_IndexColumns01 =[...SS_IndexColumns01] 
            setSS_IndexColumns01([...ss_IndexColumns01,SS_IndexColumns02[i]]);
        }
    }

    // Update SS_IndexColumns02 everytime SS_IndexColumns01 is added
    for(let i:number=0;i<SS_IndexColumns01.length;i++){
        if(SS_IndexColumns02.includes(SS_IndexColumns01[i])===false){
            let ss_IndexColumns02 =[...SS_IndexColumns02] 
            setSS_IndexColumns02([SS_IndexColumns01[i],...ss_IndexColumns02]);
        }
    }
    */
 
  //  // Delete undefined SS_IndexColumns02 object
  //  let ss_IndexColumns02:number[]=[...SS_IndexColumns02]
  //  let IsDelete02:boolean=false
  //  for(let i:number=0;i<SS_IndexColumns02.length;i++){
  //      const let_Name:TS_ColumnName|undefined=SS_Columns.find(({Key})=>Key === SS_IndexColumns02[i])
  //      if(typeof let_Name==='undefined'){
  //          ss_IndexColumns02.splice(i, 1)
  //          IsDelete02=true
  //      }
  //  }
  //  if(IsDelete02===true){
  //      setSS_IndexColumns02(ss_IndexColumns02)
  //      IsDelete02=false
  //  }
  //  
  //  for(let i:number=0;i<SS_IndexColumns02.length;i++){
  //      const let_Name:TS_ColumnName|undefined=SS_Columns.find(({Key})=>Key === SS_IndexColumns02[i])
  //      if(typeof let_Name==='undefined'){
  //          let ss_IndexColumns02:number[]=[...SS_IndexColumns02]
  //          setSS_IndexColumns02(ss_IndexColumns02.splice(i,1))
  //      }
  //  }
 
    let ss_IndexColumns01:number[]=[...SS_IndexColumns01]
    let ss_IndexColumns02:number[]=[...SS_IndexColumns02]
 
let ss_IndexColumns01:number[]=[...SS_IndexColumns01]
 
    let ss_IndexColumns01:number[]=[...SS_IndexColumns01]
 
    // This code is not finished, because it does not garantee that
    // setSS_IndexColumns01 will be updated when the element of SS_IndexColumns02 is deleted
    // and vice versa.
 
    let ss_Columns:TS_ColumnName[]=[...SS_Columns]
    // Add new key to both SS_IndexColumns01 and SS_IndexColumns02
 
        // Update SS_IndexColumns01
 
        // Update SS_IndexColumns02
 
        // else{
        //     alert(let_Name.Name)
        // }
 
            //setSS_IndexColumns01(ss_IndexColumns01.splice(i, 1))
 
alert(
 
let ss_IndexColumns01:number[]=[...SS_IndexColumns01]
 
            alert(ss_IndexColumns01[i])
            alert(i)
 
setSS_IndexColumns01(ss_IndexColumns01.splice(i, 1))
 
            break
 
            break
 
    let let_Name=SS_Columns.find(({Key})=>Key === ThisKey)
 
    
    function JSXName(ThisKey:number):string{
        const let_Name=SS_Columns.find(({Key})=>Key === ThisKey)
        if (let_Name===undefined){
            return 'undefined'
        }
        else{
            return let_Name.Name
        }
    }
 
            let ss_IndexColumns02:number[]=SS_IndexColumns02
            alert(JSON.stringify(ss_IndexColumns02))
            alert(JSON.stringify(ss_IndexColumns02[i]))
            alert(JSON.stringify(ss_IndexColumns02.splice(i,1)))
            setSS_IndexColumns02(ss_IndexColumns02.splice(i,1))
 
        // Update SS_IndexColumns02
        if(SS_IndexColumns02.includes(ss_IndexColumns[i])===false){
            let ss_IndexColumns02 =[...SS_IndexColumns02] 
            setSS_IndexColumns02([ss_IndexColumns[i],...ss_IndexColumns02]);
        }
 
        // Update SS_IndexColumns01
        if(SS_IndexColumns01.includes(ss_IndexColumns[i])===false){
            let ss_IndexColumns01 =[...SS_IndexColumns01] 
            setSS_IndexColumns01([...ss_IndexColumns01,ss_IndexColumns[i]]);
        }
 
        // Update SS_IndexColumns01
        if(SS_IndexColumns01.includes(ss_IndexColumns[i])===false){
            let ss_IndexColumns01 =[...SS_IndexColumns01] 
            setSS_IndexColumns01([...ss_IndexColumns01,ss_IndexColumns[i]]);
        }
 
        // Update SS_IndexColumns02
        if(SS_IndexColumns02.includes(ss_IndexColumns[i])===false){
            let ss_IndexColumns02 =[...SS_IndexColumns02] 
            setSS_IndexColumns02([ss_IndexColumns[i],...ss_IndexColumns02]);
        }
 
,SS_IndexColumns01,SS_IndexColumns02
 
let ss_IndexColumns:number[]=SS_Columns.map(Column=>Column.Key)
 
let ss_IndexColumns:number[]=SS_Columns.map(Column=>Column.Key)
 
let_All
 
            let let_UpdateColumn01:number
 
for(let j:number=0;j<;j++)
 
let ss_IndexColumns01 =[...SS_IndexColumns01] 
            setSS_IndexColumns01([...ss_IndexColumns01,ss_IndexColumns[i]]);
 
,SS_IndexColumns01,SS_IndexColumns02
 
ss_IndexColumns[i]
 
    // Update SS_IndexColumns02 everytime SS_IndexColumns01 is added
    for(let i:number=0;i<SS_IndexColumns01.length;i++){
        if(SS_IndexColumns02.includes(SS_IndexColumns01[i])===false){
            let ss_IndexColumns02 =[...SS_IndexColumns02] 
            setSS_IndexColumns02([SS_IndexColumns01[i],...ss_IndexColumns02]);
        }
    }
 
01
 
SS_IndexColumns01[i]
 
01.find((key) => SS_IndexColumns02.includes(key));
 
    //const let_Key01:number|undefined = SS_IndexColumns02.find((key) => SS_IndexColumns01.includes(key));

    //const let_NewKey02:number|undefined = SS_IndexColumns
 
SS_IndexColumns02[i]
 
    if (let_NewKey02 !== undefined && SS_IndexColumns02.length<SS_IndexColumns01.length) {
    let ss_IndexColumns02 =[...SS_IndexColumns02] 
    setSS_IndexColumns02([let_NewKey02,...ss_IndexColumns02]);
    }
 
(prevSS_IndexColumns02) => [...prevSS_IndexColumns02, let_Key02]
 
.Key
 
.Key
 
<div id='Body' >
<div>
<h1>Testing (Main)</h1>
{JSX_TestColumn}
</div>
<hr/>
<div>
<h1>JSX_TestColumn01</h1>
{JSX_TestColumn01}
</div>
<hr/>
<div>
<h1>JSX_TestColumn02</h1>
{JSX_TestColumn02}
</div>
</div>
 
<hr></hr>
 
</div>
 
</div>
 
        </td>
 
        <td>
 
        </td>
 
        <td>
 
<table id='C01id_Table'  >

</table>
 
{JSX_TestColumn}
<h1>JSX_TestColumn01</h1>
{JSX_TestColumn01}
<h1>JSX_TestColumn02</h1>
{JSX_TestColumn02}
 
{JSX_TestColumn}
<h1>JSX_TestColumn01</h1>
{JSX_TestColumn01}
<h1>JSX_TestColumn02</h1>
{JSX_TestColumn02}
</table>
 
.Name
 
.Name
 
const JSXName:string=SS_Columns.find(({Key})=>Key === Key).Name
 
JSON.stringify(
 
SS_Columns.find(({Key})=>Key === Key)}
 
Column.
 
()=>{
 
(Column) => 
 
const JSX_TestColumn02:JSX.Element[] = SS_IndexColumns02.map((Column)=>
        <td>
        <div>
        <td>{Column.Name}</td>
        </div>
        </td>
        );
 
        <td>{Column.Key}</td>
        <td>{Column.IsSelect.toString()}</td>
        <td>{Column.IsVisible.toString()}</td>
 
        <td>{Column.Key}</td>
        <td>{Column.IsSelect.toString()}</td>
        <td>{Column.IsVisible.toString()}</td>
 
    useEffect(()=>{
        if(SS_IndexColumns01.length!==SS_IndexColumns02.length){
            alert('Woke Fight with Sexist')
            alert(SS_IndexColumns01.length)
            alert(SS_IndexColumns02.length)
        }
    },[SS_IndexColumns01, SS_IndexColumns02])
 
    const [SS_IndexColumns,setSS_IndexColumns]=useState<number[]>(SS_Columns.map(Column=>Column.Key))
 
    let SS_IndexColumns = [...SS_IndexColumns02]
 
    let SS_IndexColumns = [...SS_IndexColumns02]
 
const [SS_IndexColumns,setSS_IndexColumns]=useState<number[]>(SS_Columns.map(Column=>Column.Key))
 
={setSS_IndexColumn02}
 
={SS_IndexColumn02}
 
}
            else if (IsFirst === false)
            {return [...Columns,let_NewColumn]}
 
            if(typeof IsFirst === 'undefined' || IsFirst === true)
 
        IsFirst?:boolean
 
let_UpdateColumns[0].Key
 
setSS_Reset:(S:number)=>void,
 
    setSS_PrivateReset,    // from ../index.js, Reset After update activate setSS_Filter
 
    setSS_PrivateReset:(S:number)=>void,  
 
        setSS_PrivateReset(Math.random())
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
    setSS_Reset:(S:number)=>void,
 
    setSS_Reset,        // Used for f_Rename, f_Delete, f_UnSelect | Reset and Update Page
 
    setSS_PrivateReset   = {setSS_PrivateReset}
 
 key={SS_PrivateReset}
 
    // Using SS_Columns useState hook and setSS_Reset
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
    setSS_Reset:(S:number)=>void,
 
    setSS_Reset 
 
    setSS_Reset:(S:number)=>void, 
 
          
 
          
 
    setSS_Reset,        // Reset After update activate setSS_Filter
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random())
 
     :(S:number       )=>void,
 
    setSS_Reset,     // from ../index.js, f_Rename, f_Delete | Reset and Update Page
 
         (Math.random())
 
           // from ../index.js, Reset after update Column
 
           :(S:number)=>void
 
key={SS_Reset}
 
setSS_Reset={setSS_Reset}
 
setSS_Reset={setSS_Reset}
 
setSS_Reset:(S:number)=>void,
 
setSS_Reset,
 
    // Reset everything in C01_Table
    const [SS_PrivateReset,setSS_PrivateReset]=useState<number>(0)
 
            setSS_Reset={setSS_Reset}
 
setSS_Reset,
 
    // Reset everything in C01_Table
    const [SS_PrivateReset,setSS_PrivateReset]=useState<number>(0)
 
                setSS_Reset={setSS_Reset}
 
    setSS_Reset={setSS_PrivateReset}
 
    setSS_Reset={setSS_Reset}
 
 key={SS_PrivateReset}
 
    setSS_Reset={setSS_Reset}
 
    SS_IndexColumns:number[],
 
    SS_IndexColumns,    // Only use with Delete
 
    SS_IndexColumns={SS_IndexColumns}
 
// from ../index.js, f_Rename, f_Delete | Reset and Update Page
 
// 
 
from ../index.js, f_Rename, f_Delete | Update SS_Column
 
setSS_Reset={setSS_Reset}
 
        // SS_IndexColumns Hook do not interact with f_Filter
 
ss_Columns:TS_ColumnName[]
 
[...SS_Columns]
 
        setSS_Reset(Math.random())
 
        setSS_Columns(ss_Columns)
 
    setSS_IndexColumn:(S:number[])=>void,
 
    setSS_IndexColumns:(S:number[])=>void
 
    setSS_Columns={setSS_Columns}
 
    setSS_Columns,      // Sort Column
 
    SS_IndexColumns={SS_IndexColumns}
 
    SS_IndexColumns   :number[],
    setSS_IndexColumns:(S:number[])=>void,
 
    SS_IndexColumns,    // Update the index of Column inside C01_Table
    setSS_IndexColumns, // -
 
Private
 
Private
 
//****************************************************************************
// JSX_01: Indicate the structure of let_FilterColumn and SS_Column
//****************************************************************************
    const JSX_Indicator:JSX.Element = <>
<h1>Indicator</h1>
<h3>SS_Column Length: {SS_Columns.length}</h3>
<h3>SS_Filter: {SS_Filter}</h3>
<h3>let_FilterColumn Type: {
    JSON.stringify(let_FilterColumns)
    // https://stackoverflow.com/questions/5612787/converting-an-object-to-a-string
}</h3>
<h3>let_FilterColumn Length: {
    let_FilterColumns.length}</h3>
<h3>let_FilterColumn: {
    let_FilterColumns.constructor.toString()
    // https://stackoverflow.com/questions/11182924/how-to-check-if-javascript-object-is-json
}</h3>
<hr/>
</>
 
    /*
    let JSX_Columns:JSX.Element[] = [...SS_PrivateColumns].map(
        (Column) => 
            {
            if(Column.IsVisible===true )
            return <div key={Column.Key}>
            <C_DefineColumn
                // Property
                ThisColumn={Column}
                // Set State Hook
                setSS_Reset={setSS_Reset}
                SS_Columns={SS_Columns}
                setSS_Columns={setSS_Columns}
            />
            </div>
            else if(Column.Name.includes(SS_Filter))
            return <div key={Column.Key}>
            <C_DefineColumn
                // Property
                ThisColumn={Column}
                // Set State Hook
                setSS_Reset={setSS_Reset}
                SS_Columns={SS_Columns}
                setSS_Columns={setSS_Columns}
            />
            </div>
            else return <></>
        }
            );
        */
 
useMemo 
 
    
    // SS_PrivateColumns is identical to SS_Columns except its object order.
    const [SS_PrivateColumns,setSS_PrivateColumns]=useState<TS_ColumnName[]>(SS_Columns)
 
        setSS_Reset={setSS_Reset}
 
    setSS_Reset         // Reset after update Column
 
    setSS_Reset       :(S:number)=>void
 
        //setSS_Reset(Math.random())
 
,false
 

    //useEffect(()=>alert('let_Columns = '+JSON.stringify(let_Columns)),[])
 
  
 
   
 
// We only use setSS_PrivateReset and SS_Columns for sorting columns.
 
from ../index.js, 
 
// from ../index.js, Update Columns
 
from ../index.js, 
 
    SS_IndexColumns    = {SS_IndexColumns}
 
    setSS_Columns = {setSS_Columns}
 
    SS_IndexColumns,      // from ../index.js, Sort Column
 
    SS_IndexColumns:number[],
 
    setSS_Columns:(S:TS_ColumnName[])=>void,
 
    setSS_Columns,
 
        setSS_Columns(ss_Columns)
 
            SS_IndexColumns={SS_IndexColumns}
            setSS_IndexColumns={setSS_IndexColumns}
 
    SS_IndexColumns:number[],
    setSS_IndexColumns:(S:number[])=>void,
 
    SS_IndexColumns,    // Only used in f_Delete
    setSS_IndexColumns,
 
let ss_IndexColumns:number[] = SS_IndexColumns
        for(let i:number=0;i<ss_IndexColumns.length;i++){
            if(Columns[i].Key===ThisColumn.Key){
                Columns.splice(i, 1);
            }
        }
 
       
 

    // useEffect(() => {
    // setSS_PrivateColumn(prevPrivateColumn => {
    //     let ss_IndexColumn = [...SS_IndexColumn];
    //     let ss_PrivateColumn = [...prevPrivateColumn]; // Use the previous state
    //     ss_PrivateColumn.sort((a, b) => {
    //         return ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key);
    //         });
    //     return ss_PrivateColumn; // Return the updated state
    //     });
    //     }, [SS_IndexColumn]); // Add SS_IndexColumn as a dependency
 

    const [count, setCount] = useState<number>(0);
    const [calculation, setCalculation] = useState<number>(0);
 
{JSX_Count}
 


    useEffect(() => {
        setCalculation(() => count ** 1.001);
    }, [count]); // <- add the count variable here

    const JSX_Count:JSX.Element=<>
<p>Count: {count}</p>
<button onClick={() => setCount((c) => c + 1)}>+</button>
<p>Calculation: {calculation}</p></>
 
    function f_UpdateEffect(){
        let ss_IndexColumn:number[]=[...SS_IndexColumn]
        let ss_PrivateColumn:TS_ColumnName[]=[...SS_Columns]
        // By ChatGPT
        ss_PrivateColumn.sort((a, b) => {
            return ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key);
        });
        setSS_PrivateColumn(()=>ss_PrivateColumn)}
 
async 
 
async function Update(){
        let ss_IndexColumn:number[]=[...SS_IndexColumn]
        let ss_PrivateColumn:TS_ColumnName[]=[...SS_PrivateColumn]
        // By ChatGPT
        ss_PrivateColumn.sort((a, b) => {
            return ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key);
        });
        setSS_PrivateColumn(()=>ss_PrivateColumn)}
 
async function Update(){
        let ss_IndexColumn:number[]=[...SS_IndexColumn]
        let ss_PrivateColumn:TS_ColumnName[]=[...SS_PrivateColumn]
        // By ChatGPT
        ss_PrivateColumn.sort((a, b) => {
            return ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key);
        });
 
let_Columns
 
alert(JSON.stringify(ss_PrivateColumn))
 
    const [SS_IndexColumn,setSS_IndexColumn]=useState<number[]>([2,4,3,0,1])
const [SS_PrivateColumn,setSS_PrivateColumn]=useState<TS_ColumnName[]>(SS_Columns)
 
    let ss_IndexColumn = [...SS_IndexColumn]
    let ss_PrivateColumn = [...SS_PrivateColumn]
    const Me_Sort = ss_PrivateColumn.slice().sort((a, b) => ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key));
    useEffect(()=>setSS_PrivateColumn(Me_Sort),[])
    // useEffect(() => {
    //     let ss_IndexColumn = [...SS_IndexColumn];
    //     let ss_Columns=[...SS_Columns]
    //     setSS_PrivateColumn(
    //     ss_Columns.sort((a, b) => {
    //       return ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key);
    //     }))}
    //     ,
    //     [SS_Columns,SS_IndexColumn]
    //     ); // Add SS_IndexColumn as a dependency
 
JSON.stringify(
 
, [SS_IndexColumn]);
 
useMemo(() => 
 
(a, b) => {
          return ss_IndexColumn.indexOf(a.Key) - ss_IndexColumn.indexOf(b.Key);
        }
 
SS_Columns,SS_IndexColumn
 
() => {
 

    }
 
let ss_IndexColumn = [...SS_IndexColumn];
        let ss_Columns=[...SS_Columns]
 
:void
 
        })});
        }, 
 
()=>{
 
;
        }
 
        return ss_PrivateColumn; // Return the updated state
 
        return ss_PrivateColumn; // Return the updated state
 
revPrivateColumn => 
 
        let ss_PrivateColumn = [...prevPrivateColumn]; // Use the previous state
 
<p>Count: {count}</p>
<button onClick={() => setCount((c) => c + 1)}>+</button>
<p>Calculation: {calculation}</p>
 
        //alert(JSON.stringify(SS_PrivateColumn))
 
        alert(JSON.stringify(ss_PrivateColumn))
 
SS_Columns
 

    let ss_PrivateColumn=[...SS_PrivateColumn]
    ArrayObject
 
.sort((a, b) => {
        return KeyArray.indexOf(a.key) - KeyArray.indexOf(b.key);
    });
 
    //const [SS_PrivateColumn,setSS_PrivateColumn]=useState<number[]>(SS_Columns.map(Column=>Column.Key))
 
const [SS_PrivateColumn,setSS_PrivateColumn]=useState<TS_ColumnName[]>(SS_Columns)
 
// Reset everything in C01_Table
    const [SS_PrivateReset,setSS_PrivateReset]=useState<number>(0)
 
const [SS_IndexColumn,setSS_IndexColumn]=useState<number[]>([4,2,3,0,1])
 
SS_Columns.map(Column=>Column.Key)
 
    //const [SS_PrivateColumns,setSS_PrivateColumns]=useState<TS_ColumnName[]>(SS_Columns)
 
Private
 
Private
 
Private
 
Private
 
//****************************************************************************
// JSX_01: Testing
//****************************************************************************
    const JSX_TestPrivateColumn:JSX.Element[] = let_PrivateColumns.map((Column)=>
        <td>
        <div>
        <td>{Column.Name}</td>
        <td>{Column.Key}</td>
        <td>{Column.IsSelect.toString()}</td>
        <td>{Column.IsVisible}</td>
        </div>
        </td>
        );
 
    // Create JSX Elements 
 
    // const ss_Columns:TS_ColumnName[]=[...SS_Columns]
    // const ss_SelectColumn:TS_ColumnName[] = (ss_Columns.filter(Column=>
    //     Column.IsSelect===true
    //     // https://react.dev/learn/rendering-lists
    // ));
 
SS_Reset={SS_Reset}
 
SS_Reset={SS_Reset}
 
SS_Reset:number,
 
SS_Reset,
 
SS_Reset:number,
 
SS_Reset,
 
key={SS_Reset}
 
key={SS_Reset}
 
key={SS_Reset}
 
            return 
 
            {
            if(Column.IsVisible===true )
 
    //
    // Filter Every Column the satisfy the condition
    for(let i:number=0;i<ss_Columns.length;i++){
        if(ss_Columns[i].Name.includes(SS_Filter)===true || ss_Columns[i].IsVisible===true){
            ss_Columns[i].IsVisible=true
        }
        else{ss_Columns[i].IsVisible=false}
    }
 
    let ss_Columns:TS_ColumnName[]=[...SS_PrivateColumns]
 
else return <h1></h1>
 
//****************************************************************************
// FUNCTION_00: Sort SS_Column
//****************************************************************************
 
</div>
 
key={SS_Reset}
 
setSS_Reset={setSS_PrivateReset}
 
        alert()
 
<>
 

<div>

</div>
 
<h1>Testing (C01_Table)</h1>
 
<table id='C01id_Table' key={SS_Reset}>
{JSX_TestColumn}
</table>
 
<table id='C01id_Table' key={SS_Reset}>
{JSX_TestPrivateColumn}
</table>
 
//****************************************************************************
// JSX_01: Testing
//****************************************************************************
    const JSX_TestPrivateColumn:JSX.Element[] = let_FilterColumns.map((Column)=>
        <td>
        <div>
        <td>{Column.Name}</td>
        <td>{Column.Key}</td>
        <td>{Column.IsSelect.toString()}</td>
        <td>{Column.IsVisible}</td>
        </div>
        </td>
        );
 
<table id='C01id_Table' key={SS_Reset}>
{JSX_TestPrivateColumn}
</table>
 
key={}
 
 key={SS_PrivateReset}
 
key={SS_Reset}
 
key={SS_Reset}
 
Private
 
</div>
 
<div>
</div>
 
</div>
 
    <div key={SS_PrivateReset}>
 
<div key={SS_Reset} id='C02id_ScrollColumnName'>
 
</div>
</div>
 
<div key={SS_PrivateReset}>
 
</div>
 
Private
 
Private
 
<div>
<h1>Testing</h1>
<table id='C01id_Table' key={SS_Reset}>
{JSX_TestPrivateColumn}
</table>
</div>
 
<h1>Testing</h1>
<table id='C01id_Table' key={SS_Reset}>
{JSX_TestPrivateColumn}
</table>
 
</table>
 
</div>
 
Name
 
        <h1></h1>
 
<C_DefineColumnButton
            ThisColumn={Column}
            SS_Columns={SS_Columns}
            setSS_Columns={setSS_Columns}
            setSS_Reset={setSS_Reset}
        />
 
let_NewColumn
 
            
 
                
 
            ]
 
    // Other Columns
 
useEffect 
 
import { useState } from 'react';
 
        //alert(JSON.stringify(ss_Columns))
 
        //alert(JSON.stringify(ss_Columns))
 
et_Update
 
</div>
 
key={SS_PrivateReset}
 
Private
 
setSS_Filter(let_Input)
 
        setSS_Columns(ss_Columns)
 
setSS_Filter(let_Input)
 
        alert(JSON.stringify(SS_Columns))
 
        alert(JSON.stringify(SS_Columns))
 
            
 
        let ss_SelectColumns:TS_ColumnName[]= [...SS_SelectColumns];
        let let_UpdateSelectColumn:TS_ColumnName[]=U_IsSelect(ss_SelectColumns,false,undefined,ThisColumn)
        setSS_SelectColumns(let_UpdateSelectColumn);
 
        let ss_SelectColumns = [...SS_SelectColumns];
        let let_UpdateSelectColumns=D_DeleteColumnName(ThisColumn,ss_SelectColumns)
        setSS_SelectColumns(let_UpdateSelectColumns);
 
        let ss_SelectColumns:TS_ColumnName[]=[...SS_SelectColumns]
        let let_UpdateSelectColumns:TS_ColumnName[]=U_RenameColumnName(ThisColumn,ss_SelectColumns,let_NewName)
        setSS_SelectColumns(let_UpdateSelectColumns);
 
        f_Display(D,ss_SelectColumns,setSS_SelectColumns)
 
        let ss_SelectColumns:TS_ColumnName[]=[...SS_SelectColumns]
 
    SS_SelectColumns:TS_ColumnName[],
    setSS_SelectColumns:(S:TS_ColumnName[])=>void,
 
    SS_SelectColumns,   // State of All Columns that appear in C01_Table
    setSS_SelectColumns,
 
SS_Reset,
setSS_Reset
 
// HOOK
 
SS_Reset:number,
setSS_Reset:(S:number)=>void
 
SS_Reset={SS_Reset}
setSS_Reset={setSS_Reset}
 
    const [SS_Reset,setSS_Reset]=useState<number>(0)
 
Select
 
Select
 
    // Create a copy of SS_Columns for Drag and Drop
    const [SS_SelectColumns,setSS_SelectColumns] = useState<TS_ColumnName[]>([...SS_Columns])
 
            if()
 
        let let_NewName:string=(document.getElementById('C02id_CreateNewColumn') as HTMLInputElement).value.toString();
 
 Local
 
        let let_NewName:string=(document.getElementById('C01id_CreateNewColumn') as HTMLInputElement).value.toString();
        
        // Update All Column
        let ss_Columns:TS_ColumnName[]=[... SS_Columns]
        let let_UpdateColumns:TS_ColumnName[]=C_CreateColumnName(ss_Columns,let_NewName)
        setSS_Columns(let_UpdateColumns)
 
        return Columns
 
                ...Columns    // Other Columns
            ]
 
[
                
 
            
 
    // Other Columns
 
                
 
                
 
            
 
    ThisColumn:TS_ColumnName,
 
    ThisColumn,
 
    // PROPERTY
    ThisColumn,
 
Select
 
Select
 
    
    useEffect(()=>{setSS_SelectColumns(SS_Columns)},[])
 

>(SS_Columns)
 
    // Create a copy of SS_Columns
    const [SS_C02Columns,setSS_C02Columns]=useState<TS_ColumnName[]
 
    const [SS_Reset,setSS_Reset]= useState<number>(0)
 
 for Drag and Drop
 
Select
 
Select
 
,let_NewName
 
Select
 
Select
 
et_VisibleColumns
 
[...
 
.filter(Column=>
        Column.IsSelect===true
        // https://react.dev/learn/rendering-lists
    )
 
            SS_SelectColumns={SS_SelectColumns}
            setSS_SelectColumns={setSS_SelectColumns}
 
        let ss_SelectColumns:TS_ColumnName[]= [...SS_SelectColumns];
        let let_UpdateSelectColumn:TS_ColumnName[]=U_IsSelect(ss_SelectColumns,false,undefined,ThisColumn)
        setSS_SelectColumns(let_UpdateSelectColumn);
 
        let ss_SelectColumns = [...SS_SelectColumns];
        let let_UpdateSelectColumns=D_DeleteColumnName(ThisColumn,ss_SelectColumns)
        setSS_SelectColumns(let_UpdateSelectColumns);
 
        let ss_SelectColumns:TS_ColumnName[]=[...SS_SelectColumns]
        let let_UpdateSelectColumns:TS_ColumnName[]=U_RenameColumnName(ThisColumn,ss_SelectColumns,let_NewName)
        setSS_SelectColumns(let_UpdateSelectColumns);
 
        let ss_SelectColumns:TS_ColumnName[]=[...SS_SelectColumns]
 
        f_Display(D,ss_SelectColumns,setSS_SelectColumns)
 
    SS_SelectColumns:TS_ColumnName[],
    setSS_SelectColumns:(S:TS_ColumnName[])=>void,
 
    SS_SelectColumns,   // State of All Columns that appear in C01_Table
    setSS_SelectColumns,
 
    useEffect(()=>{alert('Hello')},[])
 
        for(let i:number=0;i<ss_Columns.length;i++){
            if(ss_Columns[i].Key===ThisColumn.Key){
                let let_IsSelect:boolean
                if(ThisColumn.IsSelect===false){
                    let_IsSelect=true
                }
                else{
                    let_IsSelect=false
                }
                ss_Columns[i].IsSelect=let_IsSelect
                ss_Columns[i].Display=0
            }
        }
 
U_IsSelect()
 
    function f_UpdateBothList(){
        let ss_Columns:TS_ColumnName[]=[...SS_Columns]
        let ss_SelectColumns:TS_ColumnName[]=[...SS_SelectColumns]
    }
 
et let_NewName:string= (document.getElementById(C01id_Rename)as HTMLInputElement).value 
        let ss_Columns:TS_ColumnName[]=[...SS_Columns]
        let let_UpdateColumns:TS_ColumnName[]=U_RenameColumnName(ThisColumn,ss_Columns,let_NewName)
        setSS_Columns(let_UpdateColumns);
        setSS_Reset(Math.random())
 
setSS_Reset(Math.random())
 
let let_UpdateColumns:TS_ColumnName[]=U_UpdateDisplay(ThisColumn,ss_Columns,0)
        setSS_Columns(let_UpdateColumns)
        setSS_Reset(Math.random())  
 
f_UpdateDisplay(0)
 
        let ss_Columns:TS_ColumnName[]=[...SS_Columns]
 
        U_UpdateDisplay(ThisColumn,ss_Columns,1)
 
let let_UpdateColumns:TS_ColumnName[]=
 
setSS_Columns(
 
Select
 
let ss_SelectColumns = [...SS_SelectColumns];
 
setSS_Columns(let_UpdateColumns);
 
        for(let i:number=0;i<ss_Columns.length;i++){
            if(ss_Columns[i].Key===ThisColumn.Key){
                ss_Columns[i].IsSelect=false
                ss_Columns[i].Display=0
            }
        }
 
ThisColumns?:TS_ColumnName,
 
for(let i:number=0;i<Columns.length;i++){
        Columns[i].IsSelect=IsSelect
    }
 
                let let_IsSelect:boolean
                if(ThisColumn.IsSelect===false){
                    let_IsSelect=true
                }
                else{
                    let_IsSelect=false
                }
 
    const ss_Columns:TS_ColumnName[]=[...SS_SelectColumns]
 
.filter(Column=>
        Column.IsSelect===true
        // https://react.dev/learn/rendering-lists
    )
 
        alert(JSON.stringify(SS_Columns))
 
        alert(JSON.stringify(SS_Columns))
 
Select
 
Select
 
SS_Reset={SS_Reset}
setSS_Reset={setSS_Reset}
 
SS_Reset={SS_Reset}
setSS_Reset={setSS_Reset}
 
SS_Reset:number
setSS_Reset:(S:number)=>void
 
SS_Reset,
setSS_Reset
 
SS_Reset,
setSS_Reset
 
SS_Reset:number
setSS_Reset:(S:number)=>void
 

    let ss_SelectColumns:TS_ColumnName[]=SS_SelectColumns
 
//let 
 
    // Reset Column List after Update Column List (Create, Rename, Delete, Filter and Sort)
    // https://stackoverflow.com/questions/56649094/how-to-reload-a-component-part-of-page-in-reactjs
 
    const [SS_Reset, setSS_Reset] = useState<number>(1);
 
    // Reset Column List after Update Column List (Create, Rename, Delete, Filter and Sort)
    const [SS_Reset, setSS_Reset] = useState<number>(1)
 
={setSS_Reset}
 
    const [SS_Reset,setSS_Reset]=useState<number>(1)
 
    const ss_Columns:TS_ColumnName[]=SS_Columns
 
Change Mode of C_DefineColumn Components for
 
        alert(JSON.stringify(ThisColumn))
        alert(let_DefaultDisplay)
 
Select function that will appear in C01_Table with IsSelect 
 
//****************************************************************************
// FUNCTION_00: Select function that will appear in C01_Table with IsSelect 
//****************************************************************************
    const C02id_CheckButton:string = 'C01id_CheckButton'+ThisColumn.Key.toString()
    function f_OpenUnselect():void{
        let ss_Celumns:TS_ColumnName[]=SS_Columns
        U_UpdateDisplay(ThisColumn,ss_Celumns,3)
        setSS_Reset(Math.random())
        alert(JSON.stringify(ThisColumn))
        alert(let_DefaultDisplay)
    }

    function f_UnSelect():void{
        // https://react.dev/learn/responding-to-events#preventing-default-behavior
        // https://www.w3schools.com/jsref/met_document_getelementbyid.asp
        
        let ss_Columns:TS_ColumnName[]= [...SS_Columns];
        for(let i:number=0;i<ss_Columns.length;i++){
            if(ss_Columns[i].Key===ThisColumn.Key){
                let let_IsSelect:boolean
                if(ThisColumn.IsSelect===false){
                    let_IsSelect=true
                }
                else{
                    let_IsSelect=false
                }
                ss_Columns[i].IsSelect=let_IsSelect
                ss_Columns[i].Display=0
            }
        }
        setSS_Columns(ss_Columns);
        setSS_Reset(Math.random())
        // https://stackoverflow.com/questions/11688692/how-to-create-a-list-of-unique-items-in-javascript
    }
 
    const [let_DefaultDisplay,setlet_DefaultDisplay]= useState<0|1|2|3>(let_DefaultDisplay)
 
=
<>
<button className={'C01id'} onClick={f_OpenUnselect} id={C02id_CheckButton} style={{backgroundColor: "white"}}>X</button>
<button className={'C01id'} onClick={f_OpenRename}>Rename</button>
<button className={'C01id'} onClick={f_OpenDelete}>Delete</button>
<button className={'C01id'} onClick={f_OpenSetting}>...</button>
</>
 
        alert('Hello')
 
 (Column.Display===3
 
 if
 
    function f_OpenUnselect():void{
        let ss_Celumns:TS_ColumnName[]=SS_Columns
        U_UpdateDisplay(ThisColumn,ss_Celumns,3)
        setSS_Reset(Math.random())
    }
 
    let  :JSX.Element
 

    if(ThisColumn.IsSelect===true){
         =<button className={'C01id'} onClick={f_Select} id={C02id_CheckButton} style={{backgroundColor: "red"}}>X</button>
    }
    else{
         =<button className={'C01id'} onClick={f_Select} id={C02id_CheckButton} style={{backgroundColor: "white"}}>X</button>
    }
 
    type TS_Display=
 
 eather
 
    const ss_Columns:TS_ColumnName[]=SS_Columns
 
    let ss_Columns:TS_ColumnName[]=[...SS_Columns]
 
a copy of
 
        alert(JSON.stringify(let_UpdateColumns))
 
        alert('Hello')
 
import './index.css';
 
/C02_ColumnName
 
alert(JSON.stringify(let_UpdateColumns))
 
//****************************************************************************
// HOOK
//****************************************************************************

//****************************************************************************
// FUNCTION_00: By default JSX and function are in the same group.
//****************************************************************************

//****************************************************************************
// JAX_00:
//****************************************************************************
 
                {
                    //<p style={{ whiteSpace: 'nowrap' }}> {Column.Name}? </p>
                }
 
                }
 
                {
 
 {Column.Name}
 
</h1>
 
</h1>
 
style={{ whiteSpace: 'nowrap' }}
 
{Column.Name} to 
 
Rename 
 
Rename {Column.Name} to 
 
.C01id input[type="text"] {
    font-size: 5px;
}
 
_Input
 
 Column
 
<button className={'C01id_EmptyButton'}>...</button>
<button className={'C01id_EmptyButton'}>...</button>
<button className={'C01id_EmptyButton'}>...</button>
 
 onClick={f_OpenSetting}
 
<h1 className={'C01id'}>Rename to </h1><input className={'C01id'} id={C02id_Rename}></input>
 
<h1 className={'C01id'}>Rename to </h1><input className={'C01id'} id={C02id_Rename}></input>
 
        {
 
 || Column.Display===1
 
<h1 className={'C01id_Delete'}>Delete This Column?</h1>
 
        setSS_Display(2)
 
        setSS_Display(1)
 
        setSS_Display(0)
 
setSS_Reset(Math.random())
 
setSS_Reset(Math.random())
 
setSS_Reset(Math.random())
 
setSS_Reset(Math.random())
 
{
 
for(let i:number=0;i<ss_Celumns.length,)
 
    Key:number
 
for(let i:number=0;i<ss_Celumns.length,)
 
    background-color: #023445;
 
    bottom: 100px
 
    bottom: 100px;
 
    top: 100px;
 
o you sure that you want to d
 
</div>
 
<div className='C01id_DeleteButton'>
 

.C01id_DeleteButton{
    background-color: rgb(185, 29, 18);
    width: 100px;
}

 
.C01id_DeleteButton{
}
 
    background-color: rgb(185, 29, 18);
    width: 100px;
 
127)8
 
        <button className={'C01id'}>Cancel</button>
 
 onClick={f_CreateColumn}
 
<button className={'C01id'} onClick={f_ResetInput}>Cancel</button>
 
<>
<table id='C99id_Table'>
<tr>
    {JSX_TH_Column_S}
    <th>Edit</th>
</tr>
<tr>
    {JSX_BUTTON_Column_S}
    <td>-</td>
</tr>

</table>
</>
 
    const letPerson_S:TS_Person[]=[
        {Name:'Mumu'  , Gender:false, Age: 25},
        {Name:'CheChe', Gender: true, Age: 22},
        {Name:'Tata'  , Gender: true, Age: 19}
    ]

    const JSX_TH_Column_S:JSX.Element[] = letPerson_S.map(Column => <th>{Column.Name+','+Column.Gender.toString()+','+Column.Age.toString()}</th>);
    const JSX_BUTTON_Column_S:JSX.Element[] = letPerson_S.map(Column=>
        <td>
            <div id='C99id_Button'>
            <button>Edit</button>
            </div>
        </td>
        );
 
import {U_IsVisibleFalse} from '../../T02_ColumnName/U_IsVisibleFalse'
 
    setSS_Filter:(S:string)=>void,  
 
//****************************************************************************
// FUNCTION_00: Update SS_Filter, so that index.js update the new filter word.
//****************************************************************************
    function f_Reset(ss_Columns:TS_ColumnName[]):void{
        
        
    }
 
    setSS_Filter,   // from ../index.js, Filter Column that match with SS_Filter
 
        let let_Input:string = (document.getElementById('C02id_FilterColumnName') as HTMLInputElement).value
        // Reset IsVisible to false,
        // so that the only column that will appear
        // are the column with name that match with SS_Filter
 
        setSS_Filter(let_Input)
 
<td><button className='C01id_Header' /*onClick={()=>f_DSort(false)}*/>Add New Column</button></td>
 
import './index.css';
 
<U_DefineTableHeader/>
 
import U_DefineTableHeader from './Coms/U_DefineTableHeader'
 
<div className='C01id_DivHeader'>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(true)}*/>Import Data</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(true)}*/>Export Data</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(true)}*/>Export Filtered Data</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(true)}*/>Rename Table</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(true)}*/>Inspecting Table</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(true)}*/>Descending Sort Columns</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(false)}*/>Ascending Sort Columns</button></td>
<td><button className='C01id_Header' /*onClick={()=>f_DSort(false)}*/>Add New Column</button></td>
</div>
 
<>
<table id='C99id_Table'>
<tr>
    {JSX_TH_Column_S}
    <th>Edit</th>
</tr>
<tr>
    {JSX_BUTTON_Column_S}
    <td>-</td>
</tr>

</table>
</>
 
const letPerson_S:TS_Person[]=[
        {Name:'Mumu'  , Gender:false, Age: 25},
        {Name:'CheChe', Gender: true, Age: 22},
        {Name:'Tata'  , Gender: true, Age: 19}
    ]

    const JSX_TH_Column_S:JSX.Element[] = letPerson_S.map(Column => <th>{Column.Name+','+Column.Gender.toString()+','+Column.Age.toString()}</th>);
    const JSX_BUTTON_Column_S:JSX.Element[] = letPerson_S.map(Column=>
        <td>
            <div id='C99id_Button'>
            <button>Edit</button>
            </div>
        </td>
        );
 
<input></input>
 
</div>
 
overflow: hidden;
 
    height: 20px;
 
<input type='text'></input>
 
, #C01id_Table div
 
</div>
 
<div>
 
        <div>
 
        </div>
 
</div>
 
</div>
 
<h1 className='C01id'>
 
 </h1>
 
    <th><h1 className='C01id'>Create new column as </h1><input type='text'></input></th>
 
    <th><h1 className='C01id'>Create new column as </h1><input type='text'></input></th
 
</div>
 
border-top: 100px;
 
    padding-top: 120px;
 
    height:100px
 
top: 100px;
 
height: 100px;
 
<td><button className='C01id_Sort' /*onClick={()=>f_Filter([...SS_Columns])}*/>OK</button></td>
 
<div className='C01id_DivSort'>
 
    function 
 
</div>
 
<div>
 
</div>
 
<div>
 
</div>
 
<div className='C01id_ColumnButton'>
 
</td>
 
</td>
 
</td>
 
<td>
 
<td>
 
<td><h1 className={'C01id'}>{ThisColumn.Name}</h1></td>
 
            CSS='C01'
 
CSS+
 

    // CSS
    CSS:string
 
    // CSS
    // Belong to which component, mainly for CSS purpose
 
    CSS
 
                CSS='C02'
 
CSS+
 

    // CSS
    CSS:string
 
    // CSS
    // Belong to which component, mainly for CSS purpose
    CSS
 
    visibility:hidden
 
button 
 
,
button.C02id_Select,
button 
 
,
button.C01id_Select,
button 
 
,
button.C01id_Select,
button 
 
,
button.C01id_Select,
button 
 
C02
 
C02
 
 Class Name
 
    // 
 

    function f_Inspection():void{
        alert('Index')
    }
 
,index
 
                Index={index+1}
 
    Index:number,
 
,index
 
            Index={index}
 
    Index,
 
            Index={index}
 

//****************************************************************************
// FUNCTION_01: Drag and Drop Column
//****************************************************************************
    // https://youtu.be/_nZCvxJOPwU?si=ixJXOlrb40z19L2p
    function f_Drag(ss_Celumns:TS_ColumnName[]):void{
        const let_DragColumnCurrent:TS_ColumnName=ss_Celumns[Ref_DragColumn.current]
        ss_Celumns[Ref_DragColumn.current] = ss_Celumns[Ref_DragOverColumn.current]
        ss_Celumns[Ref_DragOverColumn.current] = let_DragColumnCurrent
        setSS_Columns(ss_Celumns)
        setSS_Reset(Math.random())
    }
 
    // Drag and Drop Columns
    const Ref_DragColumn = useRef<number>(0)
    const Ref_DragOverColumn = useRef<number>(0)
 
, useRef 
 
            draggable
            onDragStart={()=>{Ref_DragColumn.current=index}}
            onDragEnter={()=>{Ref_DragOverColumn.current=index}}
            onDragEnd={()=>f_Drag(let_FilterColumns)}
            onDragOver={(e)=>e.preventDefault()}
            
 
 draggable
            onDragStart={()=>{Ref_DragColumn.current=index}}
            onDragEnter={()=>{Ref_DragOverColumn.current=index}}
            onDragEnd={()=>f_Drag(let_VisibleColumn)}
            onDragOver={(e)=>e.preventDefault()}
        
 
    // Drag and Drop
 
import C_DefineColumn from './Coms/C_DefineColumn';
 
import C_DefineColumnHeader from './Coms/C_DefineColumnHeader'
 
ss_Celumns
 
:TS_ColumnName[]=[...SS_Columns]
 
        alert()
 
        alert
 
// Drag and Drop Columns
    const Ref_DragColumn = useRef<number>(Index)
    const Ref_DragOverColumn = useRef<number>(0)
 
//****************************************************************************
// FUNCTION_03: Drag and Drop Column
//****************************************************************************
    // https://youtu.be/_nZCvxJOPwU?si=ixJXOlrb40z19L2p
    function f_Drag():void{
        let ss_Celumns:TS_ColumnName[]=SS_Columns
        const let_Column:TS_ColumnName=ss_Celumns[Ref_DragColumn.current]
        ss_Celumns[Ref_DragColumn.current] = ss_Celumns[Ref_DragOverColumn.current]
        ss_Celumns[Ref_DragOverColumn.current] = let_Column
        setSS_Columns(ss_Celumns)
        setSS_Reset(Math.random())
    }
 
//    draggable
//    onDragStart={()=>{Ref_DragColumn.current=Index}}
//    onDragEnter={()=>{Ref_DragOverColumn.current=Index}}
//    onDragEnd={f_Drag}
 
//    
 
    //onDragOver={(e)=>e.preventDefault()}
 
ThisColumn.
 
ThisColumn.
 
ThisColumn.
 
                  Index:ThisColumn.Index,
 
                Index:0,
 
            ss_Columns[i].Index=i
 
    Index:number,       // Index
 
        // 
 
draggable
 
draggable
 
Row Index
 
const 
 
:JSX.Element[]
 
let_VisibleColumn.map(Column => 
 
const 
 
:JSX.Element[] 
 
overflow-x: scroll;
 
    overflow-x: scroll;
 
</td>
 
    type TS_Display=
            0|  // Default JSX Column | f_Cancel     => setSS_Display(0) => Open Default JSX Column
            1|  // Rename JSX Column  | f_OpenRename => setSS_Display(1) => Open Rename JSX Column 
            2   // Delete JSX Column  | f_OpenDelete => setSS_Display(2) => Open Delete JSX Column 
 
    const [SS_Display,setSS_Display]=useState<TS_Display>(0)
 
<td><h1 className='C02id'>{ThisColumn.Name}</h1></td>
 
<h1 className='C02id'>"{ThisColumn.Name}" to </h1>
 
const [SS_Reset,setSS_Reset]=useState<number>(1)
 
        /*
 
        */
        <>
        <div id='C01id_Button'>
        <td><h1 className='C02id'>Do you sure that you want to delete "{Column.Name}"</h1></td>
        <td><button className='C02id'>OK</button></td>
        <td><button className='C02id'>Cancel</button></td>
        </div>
        </>
 
f_Cancel
 
f_Delete
 
       
 
True
 
True
 
True
 
True(
 
        for(let i:number=0;i<ss_Columns.length;i++){
            if(ss_Columns[i].Name.includes(SS_Filter)===true){
                ss_Columns[i].IsSelect=true
            }
        }
 
_
 
 from C02_ColumnName
 
        // SS_Columns from C02_ColumnName
 
        // New Column Name
        NewName:string
 
import TS_ColumnName from "."

export function C_CreateColumnName(        
        // SS_Columns from C02_ColumnName
        Columns:TS_ColumnName[],
        // New Column Name
        NewName:string):TS_ColumnName[]{

    return Columns
}

 
// Delete the column with selected key
 
        for(let i:number=0;i<ss_Columns.length;i++){
            if(ss_Columns[i].Key===ThisColumn.Key){
                ss_Columns.splice(i, 1);
            }
        }
 
 from C02_ColumnName
 

export default {C_CreateColumnName}
 
                // Property of the New Column 
 
        // Check if the name is duplicate
 
ThisColumn:TS_ColumnName,
 
            let Columns = [...Columns];
 
        if(SS_Columns.map(Column=>Column.Name).includes(let_NewName)===false){
            let ss_Columns = [...SS_Columns];
            // Replace the previous name (the name with selected key) with new name
            for(let i:number=0;i<ss_Columns.length;i++){
                if(ss_Columns[i].Key===ThisColumn.Key){
                    ss_Columns.splice(i, 1,{
                    Key: ThisColumn.Key,
                    Name: let_NewName, 
                    IsSelect: ThisColumn.IsSelect,
                    IsVisible: true
                });
                }
            }
            return Columns
        }
 
if(SS_Columns.map(Column=>Column.Name).includes(let_NewName)===false){
            let ss_Columns = [...SS_Columns];
            // Replace the previous name (the name with selected key) with new name
            for(let i:number=0;i<ss_Columns.length;i++){
                if(ss_Columns[i].Key===ThisColumn.Key){
                    ss_Columns.splice(i, 1,{
                    Key: ThisColumn.Key,
                    Name: let_NewName, 
                    IsSelect: ThisColumn.IsSelect,
                    IsVisible: true
                });
                }
            }
        }
 
export default {C_CreateColumnName}
 
export {C_CreateColumnName}
 
 default
 
        }
 
// If the name is not longer than 50 and unique, then Create new column
        if(let_NewName.toString().length>0 
            && let_NewName.toString().length<50 
            && SS_Columns.map(Column=>Column.Name).includes(let_NewName)===false){
            // https://stackoverflow.com/questions/43846531/check-if-dictionary-object-in-array-contains-certain-value-in-javascript

            // Generate New Key
            let let_NewKey:number = Math.random()
            while(SS_Columns.map(Column=>Column.Key).includes(let_NewKey)===true){
                let_NewKey = Math.random()
            }
            
            // Add New Column in List of All Column
            // https://stackoverflow.com/questions/31048953/what-are-these-three-dots-in-react-doing
            let ss_Columns:TS_ColumnName[] = [...SS_Columns]
            let let_NewColumn:TS_ColumnName={
                // Property of the New Column 
                Key: let_NewKey,    
                Name: let_NewName, 
                IsSelect:false,
                IsVisible: true
                }
 
                ..
 
                let_NewColumn,
 
    // Other Columns
            
 
// New Column Name
 
return [
                {
                // Property of the New Column 
                Key: let_NewKey,    
                Name: NewName, 
                IsSelect:false,
                IsVisible: true
                },
                ...Columns    // Other Columns
            ]
 
        Key:number,
 
            setColumns([
                let_NewColumn,
                ...Columns    // Other Columns
            ])
 
            let let_Columns:TS_ColumnName[] = [...Columns]
 
            let Columns:TS_ColumnName[]=Columns
 
            setSS_Reset(Math.random())
 
setSS_Reset(Math.random())
 
        SelectedKey:number,
 
C99_BluePrint
 
    const letPerson_S:TS_Person[]=[
        {Name:'Mumu'  , Gender:false, Age: 25},
        {Name:'CheChe', Gender: true, Age: 22},
        {Name:'Tata'  , Gender: true, Age: 19}
    ]

    const JSX_TH_Column_S:JSX.Element[] = letPerson_S.map(Column => <th>{Column.Name+','+Column.Gender.toString()+','+Column.Age.toString()}</th>);
    const JSX_BUTTON_Column_S:JSX.Element[] = letPerson_S.map(Column=>
        <td>
            <div id='C99id_Button'>
            <button>Edit</button>
            </div>
        </td>
        );
 
import TS_Person from './Type/TS_Person';
 
    let ss_Columns:TS_ColumnName[]=[...SS_Columns]
    let let_SelectColumns
 
:TS_ColumnName[] = (ss_Columns.filter(Column=>
        Column.IsSelect===true
        // https://react.dev/learn/rendering-lists
    ));
 
SS_Columns
 
={SS_Columns}
setSS_Columns={setSS_Columns}
 
setSS_Columns={setSS_Columns}
 
    // SS_Column = Set State Column List
    const [SS_Columns,setSS_Columns]=useState<TS_ColumnName[]>(SS_COLUMNS);
 
// HOOK
 
SS_COLUMNS,
 
    for(let i:number=0;i<ss_Columns.length;i++){
        if(ss_Columns[i].IsVisible===true){
            ss_Columns[i].IsVisible=true
        }
        else{ss_Columns[i].IsVisible=false}
    }
 
ss_Columns[i].Name.includes(SS_Filter)===true || 
 
const Input:TS_ColumnName[]=
 
[
        {Key: 0, Name: 'Row Index'            , IsSelect: false, IsVisible: true},
        {Key: 1, Name: 'Weezer'               , IsSelect: false, IsVisible: true},
        {Key: 2, Name: 'Tally Hall'           , IsSelect: false, IsVisible: true},
        {Key: 3, Name: 'Que, The Human Editor', IsSelect: false, IsVisible: true},
        {Key: 4, Name: 'Human Centipede'      , IsSelect: false, IsVisible: true},
        ]
 

<div id='Body'>
<C01_Table INPUT={Input}/>
</div>
 
<div>
<table>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
<td>hdhdh</td>
</table>
</div>
</div>
 
<C01_Table INPUT={Input}/>
 
<C01_Table/>
 
_Columns
 
_Columns
 
_Columns
 
_Columns
 
     
 

const AllType=[
    TS_ColumnName,
    TS_Person
]
 

export default TS_Person
 
export 
 

export default TS_ColumnName
 
Age.toString()
 
+','+Column.Gender.toString()+','+Column.
 
    <td>-</td>
 
    <th>Edit</th>
 
</td>
 
    <th>Edit</th>
 
                alert(JSON.stringify(ss_Columns[i]))
                alert(IsSelect.toString())
 
f_Reset(let_NewColumns);
 
setSS_IsDefault(true)
        setSS_IsDeleteSelect(true)
 
let let_CountDelete:number=0
 
IsSelect:boolean
 
SS_IsDeleteSelect
 
false
 
true
 
    const [SS_IsDeleteSelect,setSS_IsDeleteSelect]= useState<boolean>(true)
 
IsSelect:boolean
 
        // Is Delete selected column?
        setSS_IsDeleteSelect(IsSelect)
 
        // Is Delete selected column?
        setSS_IsDeleteSelect(IsSelect)
 
        // Count Normally
        setSS_IsDeleteSelect(true)
 
    for(let i:number=0;i<ss_Columns.length;i++){
        if(ss_Columns[i].IsSelect===true){
            Let_CountColumn+=1
        }
    }
    let let_CountColumn2:number
    if(SS_IsDeleteSelect){
        
    }
 
IsSelect:boolean
 
            setSS_IsDeleteSelect(IsSelect)
 
Open
 
SS_IsDeleteSelect
 
    function f_OpenDeleteSelect(){
        
    }
 
f_SelectAll
 
//****************************************************************************
// FUNCTION_03: Un Select AllColumns
//****************************************************************************
    function f_DeleteUnSelect():void{
        let ss_Columns:TS_Column[]= [...SS_Columns];
        for(let i:number=0;i<ss_Columns.length;i++){
            ss_Columns[i].IsSelect=false
        }
        f_Reset(ss_Columns);
    }
 
UnSelectAl
 
        setSS_Reset(Math.random())
 
        setSS_Reset(Math.random()
 
        setSS_Reset(Math.random())
 
        let ss_Columns:TS_Column[]= [...SS_Columns];
        for(let i:number=0;i<ss_Columns.length;i++){
            ss_Columns[i].IsSelect=true
        }
 
 Filtered 
 
Filter
 
p
 
{
        let ss_Columns:TS_Column[]= [...let_FilterColumns];
        for(let i:number=0;i<ss_Columns.length;i++){
            ss_Columns[i].IsSelect=true
        }
        setSS_Columns(ss_Columns);
        setSS_Reset(Math.random())
    }
 
            if(ss_Columns[i].Key===ThisColumn.Key){
                let let_IsSelect:boolean
                if(ThisColumn.IsSelect===false){
                    let_IsSelect=true
                }
                else{
                    let_IsSelect=false
                }
                ss_Columns[i].IsSelect=let_IsSelect
            }
 
SS_Columns:TS_Column[],
 
SS_Columns,
 
<h1 id='C02id_Title'>Column</h1>
 
#C02id_Title{
    font-size: 25px;
    display: block;
}
 
    border: 1px solid rgb(205, 205, 205, 0);
    border-left: 5px solid rgb(205, 205, 205, 0);
    border-right: 5px solid rgb(205, 205, 205, 0);
 
 .C02id
 
            alert(ss_Columns[i].Name+':'+ss_Columns[i].IsSelect.toString())
 
    // Selecting only some Columns in the C01_Table
    const [SS_IsSelect,setSS_IsSelect]= useState<boolean>(ThisColumn.IsSelect)
 
 if(SS_IsSelect===true)
 
        if(SS_IsSelect===false){setSS_IsSelect(true)}
        else if(SS_IsSelect===true){setSS_IsSelect(false)}
 
alert(ss_Columns[i].Name+':'+ss_Columns[i].IsSelect.toString())
 
let ss_Columns:TS_Column[]= [...SS_Columns];
 
let JSX_SelectButton:JSX.Element
    const C02id_CheckButton:string = 'C02id_CheckButton'+ThisColumn.Key.toString()
 
        // if (SS_IsSelect===true){
        //     (document.getElementById(C02id_CheckButton)as HTMLInputElement).style.backgroundColor = "red";
        //     setSS_IsSelect(false)
        // }
        // else if (SS_IsSelect===false){
        //     (document.getElementById(C02id_CheckButton)as HTMLInputElement).style.backgroundColor = "white";
        //     setSS_IsSelect(true)}
 
        // if (SS_IsSelect===true){
        //     (document.getElementById(C02id_CheckButton)as HTMLInputElement).style.backgroundColor = "red";
        //     setSS_IsSelect(false)
        // }
        // else if (SS_IsSelect===false){
        //     (document.getElementById(C02id_CheckButton)as HTMLInputElement).style.backgroundColor = "white";
        //     setSS_IsSelect(true)}
 
        // Replace the previous name (the name with selected key) with new name
 
                ss_Columns.splice(i, 1,{
                Key: ThisColumn.Key,
                Name: ThisColumn.Name, 
                IsSelect: SS_IsSelect,
                IsVisible: true
            });
 
[...
 
    FilterColumns={let_FilterColumns}
 
    AllColumns,
 
    AllColumns:TS_Column[]
 
<h1 id='C02id_Title'>Column</h1>
 
#C02id_Title{
    font-size: 25px;
    height: 15px;
    display: grid;
}
 
    height: 100px;
 
<h1>Column</h1>
 
div className='C02id_DivSelect'
 
div
 
</div>
 
 100px
 
, 50px 1fr
 

.C02id button {
    background-color: rgb(255, 255, 255);
}
 
    mask-repeat: ;
 
    font-size: 16px;
 
<td>
 
<td>
 
</td>
 
    height:100%;
 
    margin: 0;
 
        <div className='C02id'>
 
        </div>
 
</div>
 
</div>
 
</div>
 
        <h1 className='C02id'>Wellcome to the Amazing Digital Circus</h1>
 
border-top: 100px;
 
    display: block;
    padding: 10px;
 
    position: relative;
 
    display: block;
    height:100px
 
    height:100px
 
    height: 100%;
 
    height: 100px;
 
    display: grid;
    height: 40px;
 
    .C02id;
    
 
.C02id
 
</div>
 
</td>
 
    padding:3px
 
</td>
 
</td>
 
</td>
 
</td>
        <td>
 
        <td><button className='C02id'>Select All Filtered</button></td>
 
    </>)
 
{
    // JSX.Element
}
 
import './index.css';
 
import { useState , useEffect} from 'react';
 
import C_DefineObject from './Coms/C_DefineObject';
 
import TS_Object from './Type/TS_Object';
 
// Import Order
 
Add 
 
    font-size: 18px;
 
_Main
 
#C02id_Main h1{
    font-size: 10px;
}

 
#C02id_CreateNewColumn {}
 
_Main
 
_Main
 
_Main
 
.C02id_Main{
    font-size: 3em sans-serif;
}
 
.#C02id_Main{
    display: grid
}
 
</div>
 
</div>
 
</>
 
</td>
 
<h1>
 
</h1>
 
</ti>
 
inline-block
 
lexbox
 
#C02id_CreateNewColumn{
}
 
    display: grid
 
        alert(let_NewName)
        /*
 
6. SS_ + ...  | useState()
7. TS_ + ...  | type defined
 
7. ShortName  | loop, parameter
 
2. f_ + ...   | function
 
1. JSX_ + ... | JSX.Element
 
3. SS_ + ...  | useState()
 
number
 
primative
 
letP
 
_
 
 have same name as its file (if it
 
 have same name as its folder (if it
 
// Component have same name as its folder (if it is in index.tsx)
 
,index
 
// for loop
for(let i:number=0;i<...;i++){
    // do not use leti
    // do not use thing naming technique with loop, map, render
}
 
S
 
import TS_Person from './Type/TS_Person.tsx';
 
type TS_ColumnList={
    Name:string,
    Gender:boolean,
    Age:number
}
 

const + {AnyName}:any
 
    let num:number=0
 
SS
 
const JSX_ + {DOM_Tag?} + _? + {AnyName}:JSX.Element
// DOM_Tag e.g. H1, BUTTON, TABLE, DIV etc.
// DOM_Tag? = Optional
// _? = Optional
 
const C + {N} + id_ + {AnyName} + {key?}:string
// Id and/or className of the components for input tag and CSS class
// key? = add key index, if it is exist
 
const [SS_Something, setSS_Something] = useState<type_of_SS_Something>(DefaultValue)
// SS = Set State
// type of DefaultValue === type of SS_Something === type_of_SS_Something
 
type TS_ + {AnyName} ={...}
// TS = Type Script
 
// PARAMETER
 
import C_CreateColumn from './Coms/C_CreateColumn';
import C_DefineColumn from './Coms/C_DefineColumn';
 
const AnyName+_S:AnyType[]
// List of Something
 
const JSX_ + {DOM_Tag} + _ + AnyName:JSX.Element
 
TH_Column
 
// 
 
        'C_'+AnyName
 
:JSX.Element
 
import C_CreateColumn from './Coms/C_CreateColumn';
import C_DefineColumn from './Coms/C_DefineColumn';
 
function
 
//****************************************
 
import C01_Table from "./C01_Table";
import C02_Column from "./C02_Column";

 
import { useState , useEffect} from 'react';
 
import C01_Table from "./C01_Table";
import C02_Column from "./C02_Column";
 
import TS_Column from './Type/TS_Column';
 
<U_SelectAll
    // SS_SelectAll={SS_SelectAll}
    // setSS_SelectAll={setSS_SelectAll}
    SS_Column={SS_Column}
    setSS_Column={setSS_Column}
    setSS_Reset={setSS_Reset}
/>
<U_UnSelect
    //SS_SelectAll={SS_SelectAll}
    //setSS_SelectAll={setSS_SelectAll}
    SS_Column={SS_Column}
    setSS_Column={setSS_Column}
    setSS_Reset={setSS_Reset}
/>
 
        // any is used with f_Sort 
 
:void
 
// Default Column JSX
 
=
<>
<div>
{JSX_SelectButton}
<td><button className='C02id' onClick={f_OpenRename}>Rename</button></td>
<td><button className='C02id' onClick={f_OpenDelete}>Delete</button></td>
<td><button className='C02id' onClick={f_OpenSetting}>...</button></td>
<td><h1 className='C02id'>{ThisColumn.Name}</h1></td>
</div>
</>
 
 2 => 
 
// SS_Display == 1 
// SS_Display ==
 
 2 => Delete JSX Column  | f_OpenDelete => setSS_Display(2) => Open Delete JSX Column 
 
=> Rename JSX Column  | f_OpenRename => setSS_Display(1) => Open Rename JSX Column 
 
// SS_Display == 0 => 
 
Default JSX Column | f_Cancel     => setSS_Display(0) => Open Default JSX Column
 
let_
 
let_
 
SS_
 
setSS_Reset,     // from ../index.js, f_Rename, f_Delete | Reset and Update Page
 
setSS_Reset,
 
                Index={index+1}
 
// DEFAULT: Math.random()
 
require
 
                    
 
// DEFAULT: false
 
// DEFAULT: true
 
                        /////////////////////////////
 
                        /////////////////////////////
 
                        /////////////////////////////
 
                        /////////////////////////////
 
boolean
 
     // from ../index.js, f_Rename, f_Delete | Reset and Update Page
    // https://stackoverflow.com/questions/56649094/how-to-reload-a-component-part-of-page-in-reactjs
 
                     // 1
                     // 2
                     // 3
                     // T
 
import { useState } from 'react';
 
import { useState } from 'react';
 
import './index.css';
 
import { useState , useEffect} from 'react';

 
import R_FilterColumn from './Coms/R_FilterColumn';
import C_CreateColumn from './Coms/C_CreateColumn';
import C_DefineColumn from './Coms/C_DefineColumn';
 
    Index,           // Position of each Column in SS_Column
 
    Index:number,           // Position of each Column in SS_Column
 
// TYPE
 
{
    SS_Column,       // from ../index.js, Update Columns
    setSS_Column,    // from ../index.js, Update Columns
    setSS_Reset      // from ../index.js, Reset after update Column
}:
 
} onClick={f_CreateColumn}
 
// https://stackoverflow.com/questions/31048953/what-are-these-three-dots-in-react-doing
 
{
                // Property of the New Column 
                Key: let_NewKey,    
                Name: NewColumn, 
                IsSelect:false,
                IsVisible: true
                }
 
// HOOK: setState()
 
:(S:number)=>void
 
(S:TS_Column)=>void
 
TS_Column[]
 
:{
    TS_Column[],
    React.Dispatch<React.SetStateAction<any>>,
    // https://stackoverflow.com/questions/65823778/how-can-i-define-type-for-setstate-when-react-dispatchreact-setstateactionstri
    React.Dispatch<React.SetStateAction<any>>
}
 
:{
    TS_Column[],
    React.Dispatch<React.SetStateAction<any>>,
    // https://stackoverflow.com/questions/65823778/how-can-i-define-type-for-setstate-when-react-dispatchreact-setstateactionstri
    React.Dispatch<React.SetStateAction<any>>
}
 
value:TS_Column[])=>void
 
React.Dispatch<React.SetStateAction<TS_Column[]>>
 
</React.SetStateAction>
 


    React.Dispatch<React.SetStateAction<boolean>>
 
import './index.css';
 
    type TS_Column={
    // Properties of Each Column
        Key:number,
        Name:string,        // Column Name
        IsSelect:boolean,   // Is the Column display in C01_Table
        IsVisible:boolean   // Is the Column display in C02_Column
    }
 
</React.SetStateAction>
 
/React.SetStateAction>
 
    
    // Select All Column
    const [SS_SelectAll,setSS_SelectAll]=useState(false)
 
    // Properties of Each Column
    // 0. Key        
    // 1. ColumnName
    // 2. IsSelect          // Is the Column display in C01_Table
    // 3. IsVisible      // Is the Column display in C02_Column
 
import U_SelectAll from './subcomponents/U_SelectAll'
import U_UnSelect from './subcomponents/U_UnSelect';
 
import { useState } from 'react';
 
HTML
 
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.tsx</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
 
<C00_Header/>
 
<C02_Column/>
 
import { useState , useEffect} from 'react';
import './index.css';
import R_FilterColumn from './Coms/R_FilterColumn';
import C_CreateColumn from './Coms/C_CreateColumn';
import C_DefineColumn from './Coms/C_DefineColumn';

const C02_Column = (
//****************************************************************************
// INPUT
//****************************************************************************
) => {
//****************************************************************************
// HOOK
//****************************************************************************
    // Reset Column List after Update Column List (Create, Rename, Delete, Filter and Sort)
    const [SS_Reset, setSS_Reset] = useState<number>(1);
    // https://stackoverflow.com/questions/56649094/how-to-reload-a-component-part-of-page-in-reactjs

    // SS_Column = Set State Column List
    // Properties of Each Column
    // 0. Key        
    // 1. ColumnName
    // 2. IsSelect          // Is the Column display in C01_Table
    // 3. IsVisible      // Is the Column display in C02_Column
    const [SS_Column,setSS_Column]=useState([
        {Key: 0, Name: 'Row Index'            , IsSelect: false, IsVisible: true},
        {Key: 1, Name: 'Weezer'               , IsSelect: false, IsVisible: true},
        {Key: 2, Name: 'Tally Hall'           , IsSelect: false, IsVisible: true},
        {Key: 3, Name: 'Que, The Human Editor', IsSelect: false, IsVisible: true},
        {Key: 4, Name: 'Human Centipede'      , IsSelect: false, IsVisible: true},
        ]);

    // SS_Filter filter Column by Search Name
    const [SS_Filter,setSS_Filter]=useState('');
    
    // Select All Column
    const [SS_SelectAll,setSS_SelectAll]=useState(false)

//****************************************************************************
// JSX_00: Filter SS_Column.Name by IsVisible=true
//****************************************************************************
    let ss_Column=[...SS_Column]

    // Every columns that satisfy 1 of 3 conditions will IsVisible = true and appear in C02_Column
    //
    // 1. Consist of SS_Filter in their name
    //
    // 2. Created (C_CreateColumn: [f_CreateColumn]) as the New Column 
    // before being update (R_FilterColumn.js: [f_Filter, f_SortD])
    //
    // 3. Renamed (C_DefineColumn: [f_Rename]) Column 
    // before being update (R_FilterColumn.js: [f_Filter, f_SortD])
    //
    // Filter Every Column the satisfy the condition
    for(let i=0;i<ss_Column.length;i++){
        if(ss_Column[i].Name.includes(SS_Filter)===true || ss_Column[i].IsVisible===true){
            ss_Column[i].IsVisible=true
        }
        else{ss_Column[i].IsVisible=false}
    }
    let let_FilterColumn = (SS_Column.filter(Column=>
        Column.IsVisible===true
        // https://react.dev/learn/rendering-lists
    ));
    let JSX_Column = let_FilterColumn.map(
        (Column,index) => 
            <div key={Column.Key}>
            <C_DefineColumn
                // Property
                Index={index+1}
                Key={Column.Key} 
                ColumnName={Column.Name}
                IsSelect={Column.IsSelect}
                IsVisible={Column.IsVisible}
                // Set State Hook
                setSS_Reset={setSS_Reset}
                SS_Column={SS_Column}
                setSS_Column={setSS_Column}
            />
            </div>
            );
    // https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key
    // https://youtu.be/XtS14dXwvwE?si=rYQOe_tJbxmSnDWE
    // https://react.dev/learn/rendering-lists#where-to-get-your-key
    // https://stackoverflow.com/questions/72217570/insert-counter-in-a-reactjs-map

//****************************************************************************
// JSX_01: Indicate the structure of let_FilterColumn and SS_Column
//****************************************************************************
    const Indicator = <>
<h1>Indicator</h1>
<h3>SS_Column Length: {SS_Column.length}</h3>
<h3>SS_Filter: {SS_Filter}</h3>
<h3>let_FilterColumn Type: {
    JSON.stringify(let_FilterColumn)
    // https://stackoverflow.com/questions/5612787/converting-an-object-to-a-string
}</h3>
<h3>let_FilterColumn Length: {
    let_FilterColumn.length}</h3>
<h3>let_FilterColumn: {
    let_FilterColumn.constructor.toString()
    // https://stackoverflow.com/questions/11182924/how-to-check-if-javascript-object-is-json
}</h3>
<hr/>
</>
//****************************************************************************
// OUTPUT
//****************************************************************************
    return (
<>
<div id='C02id_Div'>
{
// Create New Column in Column List
}
<C_CreateColumn 
    SS_Column={SS_Column} 
    setSS_Column={setSS_Column}
    setSS_Reset={setSS_Reset}
/>
<hr/>
{
// Filter and Sort Column List
}
<R_FilterColumn 
    setSS_Filter={setSS_Filter} 
    setSS_Reset={setSS_Reset}
    SS_Column={SS_Column}
    setSS_Column={setSS_Column}
/>
<hr/>
<U_SelectAll
    SS_SelectAll={SS_SelectAll}
    setSS_SelectAll={setSS_SelectAll}
    SS_Column={SS_Column}
    setSS_Column={setSS_Column}
    setSS_Reset={setSS_Reset}
/>
<U_UnSelect
    SS_SelectAll={SS_SelectAll}
    setSS_SelectAll={setSS_SelectAll}
    SS_Column={SS_Column}
    setSS_Column={setSS_Column}
    setSS_Reset={setSS_Reset}
/>
<hr/>
{
// JSX_Column = List of all visible column
// SS_Reset only reset {JSX_Column}
}
<div key={SS_Reset} id='C02id_ScrollColumnName'>
{JSX_Column}
</div>

<hr/>
</div>
</>
)
}
//****************************************************************************
export default C02_Column
 
import U_SelectAll from './subcomponents/U_SelectAll'
import U_UnSelect from './subcomponents/U_UnSelect';
 

function MyButton({ title }: { title: string }) {
  return (
    <button>{title}</button>
  );
}

function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton title="I'm a button" />
    </div>
  );
}
 
: { title: string }
 
